#!/usr/bin/env python3

import sys
import re
import csv
from os import listdir, makedirs
from os.path import isfile, isdir, join, exists


"""
=== Documentation ===

Code convention :

* common variable names and attributes :
    l : list
    d : dictionnary
    k : k taken from dictionnary
    eltm : element taken from a list
    t : timestamp (int)

Data structures :

* class Collaborator
    * words_read
        purposes : stores all words reads by the Collaborator
        words_read = {
        'one_word_read' : [
            (timestamp, <word_oject>), //for each received
                                       //and sent by the same writer
            ...
        ],
        ...
        }
    * words_written
        purposes : stores all words written by the Collaborator
        There is only one unique word given by writer
        (only if it is a writer)
        words_written : [
            (timestamp, <word_oject>), //for each word sent
            ...
        ]
    * delays
        purposes : stores all delays of messages sent by the collaborator
        The delay is measured between the emission time and the reception
        for all other collaborators (only if it is a writer)
        delays = [
            (word_written_rank, [
                <delay_object> //for each recipient
                ...
            ]), //for each message emitted
            ...
        ]
    * lost_messages
        purposes : stores loss rate for all emitted messages
        (only if it is a writer)
        lost_messages = [
            (word_written_rank, [
                reader_id, //reader id of collaborator
                           //which didn't receive the message
                ...
            ]), //for each message emitted
            ...
        ]


"""

FILTER = '[Tracker]'

"""
=== UTILS ===
"""


def getTxtFiles(path):
    regexp = re.compile(r'.*txt$')
    files = [f for f in listdir(path) if isfile(join(path, f))]
    return [f for f in files if re.search(regexp, f) is not None]


def getFirstKey(elmt):
    return elmt[0]


def isCausal(d):
    # Tests the causality of received messages
    res = True
    for k, l in d.items():
        for i, w in enumerate(l):
            if i > 0:
                if w[1].rk < l[i - 1][1].rk:
                    print("Causality issue !")
                    print(" Work %s with rank %s arrived before work rank %s",
                          w.word, l[i - 1].rk, w.rk)
                    res = False
    return res


def getRoundTime(t):
    # Rounds timestamp given (p = 100ms)
    return int(round(int(t), -2))

"""
=== CLASS ===
"""


class File(object):
    """docstring for File"""
    def __init__(self, file_name, path):
        self.id = file_name[:-4]  # id of concerned collaborator
        self.records = []  # all records store in the file (one record by line)
        with open(path + file_name, 'r') as content:
            for l in content:
                r = Record(l)
                if len(self.records) > 0:
                    if(self.records[-1].timestamp != r.timestamp or
                       self.records[-1].word.word != r.word.word):
                        # ignore duplicated lines
                        self.records.append(r)
                else:
                    self.records.append(r)


class Record(object):
    """docstring for Record"""
    def __init__(self, l):
        cl = l[len(FILTER) + 1:]
        (prefix, sufix) = cl.split('\n')[0].split(':')
        prefix_split = prefix.split(' ')
        if prefix_split[2] == 'received' or prefix_split[2] == 'Received':
            self.op = 'r'  # operation may  be either 'receive message' ...
        else:
            self.op = 'w'  # or 'send message'
        self.timestamp = getRoundTime(prefix_split[0][1:-1])  # round timestamp
        self.word = Word(sufix[1:])  # concerned word


class Word(object):
    """docstring for Word"""
    def __init__(self, value):
        s = value.split(';')
        self.word = s[0]  # unique word given by writer
        self.rk = int(s[1])  # rank of message


class Delay(object):
    """docstring for Delay"""
    def __init__(self, dest, send_time, delay):
        self.dest = dest
        self.send_time = send_time
        self.delay = delay


class Collaborator(object):
    """docstring for Collaborator"""
    def __init__(self, id):
        self.id = id  # id of collaborator
        self.words_read = dict()  # refer to the doc above
        self.words_written = list()  # refer to the doc above
        self.delays = list()  # refer to the doc above
        self.lost_messages = list()  # refer to the doc above


class MainComputation(object):
    """docstring for MainComputation"""
    def __init__(self):
        self.collaborators = list()

    def recordResults(self, files):
        # from file objects, creates collaborators and feeds collaborators list
        for f in files:
            collab = Collaborator(f.id)
            for rec in f.records:
                if rec.op == 'r':
                    if rec.word.word not in collab.words_read:
                        collab.words_read[rec.word.word] = list()

                    collab.words_read[rec.word.word].append(
                        (rec.timestamp, rec.word))
                else:
                    collab.words_written.append((rec.timestamp, rec.word))

            if len(collab.words_read) > 0:
                for k, l in collab.words_read.items():
                    l.sort(key=getFirstKey)

            if len(collab.words_written) > 0:
                collab.words_written.sort(key=getFirstKey)
            self.collaborators.append(collab)

    def checkCausality(self):
        # Check the causality of all received messages for all collaborators
        res = True
        for collab in self.collaborators:
            res = res and isCausal(collab.words_read)
        return res

    def computeDelays(self):
        # Compute the delays for all messags emitted by writers
        for collab in self.collaborators:
            if len(collab.words_written) > 0:
                # for each writer
                lost_messages_list_global = list()
                delays_list_global = list()
                for word_written in collab.words_written:
                    # for each word emitted
                    delays_list = list()
                    lost_messages_list = list()

                    word_written_send_t = word_written[0]
                    word_written_rk = word_written[1].rk
                    word_written_w = word_written[1].word

                    for reader in self.collaborators:
                        # for each collaborator (as a reader)
                        if word_written_w in reader.words_read:
                            # check if word has been received at least ones
                            for word_read in reader.words_read[word_written_w]:
                                # for each message received and emmited by the
                                # same writer (ie. collab)
                                if word_read[1].rk == word_written_rk:
                                    d = word_read[0] - word_written_send_t
                                    if d < 0:
                                        d = 0
                                    delay = Delay(reader.id,
                                                  word_written_send_t,
                                                  d)
                                    delays_list.append(delay)
                                    break
                                elif(word_read[1].rk > word_written_rk or
                                     id(word_read) == id(
                                         reader.words_read[word_written_w][-1]
                                         )):
                                    lost_messages_list.append(reader.id)
                                    print("Packet lost")
                                    print(reader.id)
                                    print(word_read[1].rk)
                                    print(word_read[0])
                                    break
                        else:
                            lost_messages_list.append(reader.id)
                            print("Packet lost")
                            print(reader.id)

                    lost_messages_tuple = (word_written_rk, lost_messages_list)
                    lost_messages_list_global.append(lost_messages_tuple)

                    delays_tuple = (word_written_rk, delays_list)
                    delays_list_global.append(delays_tuple)

                collab.lost_messages = lost_messages_list_global
                collab.delays = delays_list_global

    def display_report(self):
        for collab in self.collaborators:
            print("=== Collaborator : %s ===" % collab.id)
            if len(collab.words_written) > 0:
                print("* It is a writer : %s" %
                      collab.words_written[0][1].word)
                print("** It has sent : %s messages" %
                      len(collab.words_written))
            print("* It has received : ")
            for k, m_received in collab.words_read.items():
                print("** %s : %s times", k, len(m_received))

    def export(self, path):
        # exports all delays and loss rates into csv files
        for collab in self.collaborators:
            if len(collab.words_written) > 0:
                fname = ''.join((path, '/', collab.id, '_delays.csv'))
                file = open(fname, "w")
                try:
                    writer = csv.writer(file)
                    for delay in collab.delays:
                        t = [d.delay for d in delay[1]]
                        t.insert(0, delay[0])
                        writer.writerow(t)
                finally:
                    file.close()
            if len(collab.lost_messages) > 0:
                fname = ''.join((path, '/', collab.id, '_loss-rate.csv'))
                file = open(fname, "w")
                try:
                    writer = csv.writer(file)
                    nbr_collaborators = float(len(self.collaborators) - 1)
                    for lost_message in collab.lost_messages:
                        rate = len(lost_message[1]) / nbr_collaborators
                        t = [lost_message[0], rate]
                        writer.writerow(t)
                finally:
                    file.close()


if __name__ == '__main__':
    if len(sys.argv) < 3:
        print('usage : compute_delay.py path_to_sources_dir path_to_save_dir')
        sys.exit(1)

    path_to_sources_dir = sys.argv[1]
    if not isdir(path_to_sources_dir):
        print('The path to sources dir given is not correct')
        sys.exit(1)

    path_to_save_dir = sys.argv[2]
    if not exists(path_to_save_dir):
        makedirs(path_to_save_dir)
        print("Save directory has been created")

    files = getTxtFiles(path_to_sources_dir)
    if len(files) < 2:
        print('Not enough result files into the directory given')
        sys.exit(1)

    print("=== Files are loading ===")
    file_recorded = []
    for f in files:
        new_record = File(f, path_to_sources_dir)
        file_recorded.append(new_record)

    main_computation = MainComputation()
    main_computation.recordResults(file_recorded)
    if main_computation.checkCausality():
        print("=== Causality is checked ===")
        main_computation.computeDelays()
        print("=== Delays has been computed ===")
        main_computation.display_report()
        main_computation.export(path_to_save_dir)
    else:
        print("Causality issue !!")
